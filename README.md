# MIT6.006
一点一点学习Algorithm中，记录学习的过程

2023/1/5
今天完成了ps1中的代码部分的作业，主要是练习双向链表doble_linked_list的一些基本操作
特别需要注意的点是在链表为特殊情况下的处理，比如链表为空，链表只有一个节点等情况下，删除，插入会需要注意head和tail的处理；以及插入删除时节点的next,prev的变化处理。

2023/1/6
lec03 video 
sorting,用递归的方法实现的选择排序selection-sort,插入排序insertion-sort,归并排序merge-sort

lec04 notes
Direct-Access-Array 
Hashing (smaller dynamic direct access array)(还未深入理解，有待继续学习）


2023/1/22
ps2
Problem 2-2 Sorting Sorts
selection-sort insert-sort merge-sort
(a)Selection-sort:因为在a情况下，数据结构D支持的set_at(i,x)操作在最坏情况下花费Θ(nlogn)的时间，而get_at(i)操作在最坏情况下只花费Θ(1)的时间，
因而在排序的时候set_at(i,x)操作是影响运行时间的关键项，所以需要选择一个执行set_at(i,x)操作最少的排序算法。
在选择排序、插入排序、归并排序三种排序算法中，选择排序所执行的set_at(i,x)操作是最少的。因为它确认好每一轮排序时的最大值（或最小值）的位置后，
对这个最大值（或最小值）只执行一次set_at(i,x)操作,与这个值交换位置的值也只执行一次set_at(i,x)操作，即每一轮排序时在最坏情况下执行Ο(1)次set_at(i,x)操作;
因而选择排序在最坏情况下执行Ο(n)次set_at(i,x)操作;则选择排序下，D排好序所需时间为Θ(n^2*logn)
而其他两种排序算法:插入排序在每一轮排序时执行2i次set_at(i,x)操作，因而选择排序在最坏情况下执行Ο(n^2)次set_at(i,x)操作，则选择排序下D排好序所需时间为Θ(n^3*logn);
归并排序在每一轮排序中最坏情况下执行Ο(n)次set_at(i,x)操作，共有logn轮排序，因而选择排序在最坏情况下执行Ο(nlogn)次set_at(i,x)操作，则归并排序下D排好序所需时间为Θ((nlogn)^2);
综上，选择 选择排序，执行时间为Θ(n^2*logn)。

(b)由题意可得，需要选择一个执行比较操作最少的算法。
选择排序和插入排序都需要执行Ο(n^2)比较操作，而归并排序需要执行Ο(nlogn)次比较操作；
因而选择 归并排序，执行时间为Θ(n(logn)^2)

(c)由题意可得，A是有部分值出于排好序的状态，需要选择一个执行交换操作最少且能够利用部分数据已排好序的特点的算法。
假设A有i个数据被打乱顺序，剩余n-i个数据没有被打乱顺序。则选择排序需要执行Ο(n)次交换操作，插入排序需要执行Ο(n^2)次
交换操作,归并排序需要执行Ο(nlogn)次交换操作,与A的有序度无关。
综上，选择 选择排序，执行时间为Θ(nloglogn)
